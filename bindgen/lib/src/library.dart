import 'package:meta/meta.dart';
import 'package:recase/recase.dart';
import 'package:bindgen/src/code_buffer.dart';
import 'package:bindgen/src/declaration.dart';
import 'package:bindgen/src/types.dart';

class Library {
  const Library({
    @required this.name,
    @required this.members,
  });

  final String name;
  final List<Declaration> members;

  String toDart() {
    final buf = CodeBuffer();

    buf.addLine('/// Auto-generated file: Do not edit unless you know what you are doing');
    buf.addLine('/// Dart bindings for $name, generated by bindgen');
    buf.addImport('dart:ffi', as: 'ffi');
    buf.addImport('package:ffi/ffi.dart', as: 'ffi');
    buf.addImport('package:dlopen/dlopen.dart', show: 'DlOpen');
    buf.addLine();

    _write(buf, members.whereType<EnumDeclaration>());
    _write(buf, members.whereType<StructDeclaration>());
    _write(buf, members.whereType<FunctionDeclaration>());

    buf.addClass('Lib${name.pascalCase}', builder: (classBuf) {
      _writeSymbolLookup(classBuf, name);
      _writeFunctions(classBuf, members.whereType<FunctionDeclaration>());
    });

    return buf.toString();
  }
}

void _write<T extends Declaration>(CodeBuffer buf, Iterable<T> declarations) {
  void Function(CodeBuffer, T) writer = (() {
    switch (T) {
      case EnumDeclaration: return _writeEnum;
      case StructDeclaration: return _writeStruct;
      case FunctionDeclaration: return _writeFunctionDef;
      default: throw ArgumentError('$T should be a top-level declaration type');
    }
  })();

  for (var decl in declarations) {
    writer(buf, decl);
  }
  buf.addLine();
}

void _writeEnum(CodeBuffer buf, EnumDeclaration decl) {
  if (decl.isSimple) {
    buf.addEnum(decl.name, constants: decl.constants.keys);
  }
  else {
    buf.addClass(decl.name, builder: (classBuf) {
      classBuf.addSpacedLine('const ${decl.name}._(this.index, this._name);');
      classBuf.addLine('final int index;');
      classBuf.addSpacedLine('final String _name;');

      classBuf.addGetter('name', type: 'String', expression: '_name');
      classBuf.addFunction('toString', returns: 'String', override: true, expression: "'${decl.name}.\${name}'");
      classBuf.addLine();
      
      decl.constants.forEach((constant, value) {
        classBuf.addLine("static const $constant = ${decl.name}._($value, '$constant');");
      });

      classBuf.addLine();
      classBuf.addArray('static const values', decl.constants.keys.toList());
    });
  }

  buf.addLine();
}

void _writeStruct(CodeBuffer buf, StructDeclaration decl) {
  buf.addClass(decl.name, parent: 'ffi.Struct', builder: (classBuf) {
    var lastField = decl.fields.last;
    for (var field in decl.fields) {
      if (field.type.isPrimitive) classBuf.addLine('@${field.type.native}()');
      classBuf.addLine('${field.type.dart} ${field.name};');
      if (field != lastField) classBuf.addLine();
    }
  });
  buf.addLine();
}

void _writeFunctionDef(CodeBuffer buf, FunctionDeclaration decl) {
  var def = decl.typedef;

  buf.assertTopLevel();
  buf.addLine('typedef ${def.nativeName} = ${def.native};');
  if (def.dart != def.native) {
    buf.addLine('typedef ${def.dartName} = ${def.dart};');
  }
  buf.addLine();
}

void _writeSymbolLookup(CodeBuffer buf, String name) {
  buf.addLine('static ffi.DynamicLibrary _lib;');
  buf.addLine('static final _symbolCache = <String, Function>{};');
  buf.addLine('static final \$open = DlOpen();');
  buf.addLine();
  buf.addFunction(
    '_\$getDartFunctionFromCache',
    typeParams: ['T'],
    returns: 'T',
    args: ['String name'],
    builder: (CodeBuffer funcBuf) {
      funcBuf.addLine('final func = _symbolCache[name];');
      funcBuf.openBlock('if (func == null)');
      funcBuf.addLine("_lib ??= \$open('$name');");
      funcBuf.closeBlock(addLine: true);
      funcBuf.addLine('return func as T;');
    }
  );
}

void _writeFunctions(CodeBuffer buf, Iterable<FunctionDeclaration> funcs) {
  for (var func in funcs) {
    final def = func.typedef;
    var dartType = def.dart == def.native ? def.nativeName : def.dartName;
    final args = func.arguments.map((arg) => arg.type.cValueOf(arg.name)).join(', ');
    var name = "'${func.name}'";

    buf.addLine();
    buf.addFunction(
      func.name.camelCase,
      returns: func.returnType.dartRepresentation,
      args: func.arguments.map((arg) => arg.dartRepresentation),
      builder: (funcBuf) {
        funcBuf.addLine('${func.returnType.dart} result;');
        funcBuf.addLine('var cachedFunc = _\$getDartFunctionFromCache<$dartType>($name);');
        funcBuf.openBlock('if (cachedFunc != null)');
        funcBuf.addLine('result = cachedFunc($args);');
        funcBuf.closeBlock();
        funcBuf.openBlock('else');
        funcBuf.addLine('_symbolCache[$name] = _lib.lookupFunction<${def.nativeName}, ${dartType}>($name);');
        funcBuf.addLine('result = _symbolCache[$name]($args);');
        funcBuf.closeBlock();
        funcBuf.addLine('return ${func.returnType.dartValueOf('result')};');
      },
    );
  }
}

extension on FfiType {
  String cValueOf(String expression) {
    if (kind == FfiTypeKind.enumerated) return '($expression).index';

    return expression;
  }

  String dartValueOf(String expression) {
    if (kind == FfiTypeKind.enumerated) {
      return '$alias.values.firstWhere((v) => v.index == $expression)';
    }

    return expression;
  }
}
